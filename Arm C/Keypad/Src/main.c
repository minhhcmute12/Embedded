/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
/*
 * S28: Keypad
 * Cách hoạt động: dựa trên giá trị 8bit (4bit hàng cột và 4 bit hàng ngang)
 * Khi phím nào đc nhấn thì giá trị hàng và cột liên quan là LOW=0,
 * Các vị trí khác vẫn giữ mức HIGH
 *
 * Tại sao sử dụng pull-up resistors(1==ko_nhấn==high -> 0==nhấn==low)(S28:Keypad -> V174)
 * Pull-up resistors (tạm dịch là tụt áp kéo lên) là các trở kháng được sử dụng trong các hệ thống nhúng để
 * đảm bảo tín hiệu đầu vào luôn có giá trị xác định, đặc biệt là trong trường hợp không có thiết bị nào
 * kết nối đến đầu vào đó hoặc các hiện tượng như lờn nút nhấn gây nhiễu(mấp mô) tín hiệu đầu vào.

 * Trong hệ thống nhúng, các chân đầu vào trên vi điều khiển thường được kết nối với các bộ cảm biến,
 * các công tắc hoặc các tín hiệu từ bên ngoài. Khi không có thiết bị nào kết nối với đầu vào đó,
 * tín hiệu trên chân đầu vào có thể trở thành giá trị không xác định hoặc dao động, gây ra các vấn đề
 * về độ tin cậy của hệ thống.

 * Để giải quyết vấn đề này, pull-up resistors được sử dụng để đảm bảo rằng đầu vào luôn có giá trị xác định khi
 * không có thiết bị nào kết nối đến. Pull-up resistors được kết nối từ đầu vào tới nguồn điện, đảm bảo rằng
 * tín hiệu đầu vào sẽ luôn có giá trị cao (hoặc gần giá trị cao) khi không có thiết bị nào kết nối đến.

 * Khi có thiết bị kết nối đến đầu vào, tín hiệu từ thiết bị đó sẽ có ưu tiên và đè lên tín hiệu từ pull-up resistor,
 * làm thay đổi giá trị đầu vào(có tín hiệu điều khiển xác định) của vi điều khiển.

 * Vì vậy, pull-up resistors là một phương pháp đơn giản và hiệu quả để đảm bảo tính ổn định và tin cậy của hệ thống nhúng
 * trong các trường hợp không có thiết bị nào kết nối đến đầu vào.
 *
 * Phân biệt:
 * Pull-up resistors(điện trở kéo lên): dây_tín_hiệu -> điện trở 22k -> VDD
 * Pull-down resistors(điện trở kéo xuống): dây_tín_hiệu -> điện trở 22k -> GND
 * */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include<stdint.h>
#include<stdio.h>

//Chống dội phím
void delay()
{
	for(uint32_t i = 0; i < 250000; i++);

	/*
	 * Tính toán thời gian delay
	 * Vi điều khiển STM32 sử dụng thạch anh có tần số 16Mhz
	 * 1 lệnh xử lý (instruction) = 1 xung clock
	 * 1 ins = 0.0625 micro seconds
	 * 1 chu trình xử lý vòng lặp for cần 7 lệnh: 7 ins = 0.5 micro seconds
	 *
	 * -> 0.5 micro seconds -> 1 vòng lặp
	 * -> 1000 micro seconds -> 2000 vòng lặp
	 *
	 * Để chống dội cần 150ms -> 150 * 2000 = 300000+- lần vòng lặp
	 * */
}

int main(void)
{
	//Định nghĩa, cấu hình địa chỉ cho các thanh ghi ngoại vi
	uint32_t volatile *const pGPIODModeReg = (uint32_t*)(0x40020C00);	//8.4.1(GPIOx_MODER)
	uint32_t volatile *const pInPutDataReg = (uint32_t*)(0x40020C00 + 0x10);
	uint32_t volatile *const pOutPutDataReg = (uint32_t*)(0x40020C00 + 0x14);
	uint32_t volatile *const pClockCtrlReg = (uint32_t*)(0x40023800 + 0x30); //RCC_AHB1ENR
	uint32_t volatile *const pPullupDownReg = (uint32_t*)(0x40020C00 + 0x0C);  //8.4.4_GPIOx_PUPDR

	//1. Cấu hình xung clock cho thanh ghi ngoại vi PortD
	*pClockCtrlReg |= (1 << 3);

	//2. Cấu hình PD0,PD1,PD2,PD3 làm đầu ra output (rows)
	*pGPIODModeReg &= ~(0xFF);    //clear tất cả pin_cặp_bit về 00, phòng trường hợp thanh ghi đã đc sử dụng trước đó
	//ở đây ta cần set pin_cặp_bit từ Moder0->Moder3 = 01(set pull-up)
	*pGPIODModeReg |= 0x55; 	// 0101 0101 = 0x55, set các pin_cặp_bit len 01

	//3. Cấu hình PD8,PD9,PD10,PD11 làm đầu vào input (columns)
	////ở đây ta cần set pin_cặp_bit từ Moder8->Moder11 = 00
	*pGPIODModeReg &= ~(0xFF << 16);		//set value 00 bit từ vị trí bit 16

	//4. Set pull-up cho PD8,PD9,PD10,PD11
	//ở đây ta cần set pin_cặp_bit từ PUPDR8->PUPDR8 = 01(set pull-up)
	*pPullupDownReg &= ~(0xFF << 16);    //clear bit tù vị trí bit 16
	*pPullupDownReg |= (0x55 << 16);	// set các pin_cặp_bit len 01, cấu hình pull-up

	//Hỏi: tại sao sử dụng thêm thanh ghi GPIOx_PUPDR cho tín hiệu input
	//trong khi tín hiệu output không cần
	//Giải thích: khi GPIOx_MODER(thanh ghi của vi điều khiển) là output thì tín hiệu đầu ra
	//luôn luôn sẽ là 0 hoặc 1. Tuy nhiên, vì tín hiệu input có thể là 1 value không xác định
	//bị nhiễu, hoặc dao động điện áp nên sẽ ko xác định đc value input là 0 hoặc 1. Chính vì thế
	//ta phải sử dụng thanh ghi có tích hợp pull-up resistor để lọc, khử nhiễu giá trị input.

	//Lưu ý: thanh ghi gốc đang xử lý là thanh ghi 32 bit GPIOx_MODER = 0x40020C00.
	//Các thanh ghi pPullupDownReg,pClockCtrlReg,.. là các thanh ghi bổ sung tính năng cho thanh ghi gốc
	//Vd: khi ta cấu hình input cho PD8,PD9,PD10,PD11 trên thanh ghi GPIOx_MODER, tuy nhiên vì muốn
	//lọc, khử nhiễu input nên ta sử dụng thêm thanh ghi pPullupDownReg để các chân PD8,PD9,PD10,PD11
	//có thêm khả năng pull-up.

	while(1)
	{
		//5.1 Thiet lap Rows len muc cao high
		*pOutPutDataReg |= 0x0F;

		//6.1 Thiet lap R1 LOW(PD0)
		*pOutPutDataReg &= ~(1 << 0);

		//7.1 Quet cac cot
		//Check C1(PD8) low or high
		if(!(*pInPutDataReg & (1 << 8)))
		{
			//key dc nhan
			delay();
			printf("1\n");
		}

		//Check C2(PD9) low or high
		if(!(*pInPutDataReg & (1 << 9)))
		{
			//key dc nhan
			delay();
			printf("2\n");
		}

		//Check C3(PD10) low or high
		if(!(*pInPutDataReg & (1 << 10)))
		{
			//key dc nhan
			delay();
			printf("3\n");
		}

		//Check C4(PD11) low or high
		if(!(*pInPutDataReg & (1 << 11)))
		{
			//key dc nhan
			delay();
			printf("A\n");
		}


		//5.2 Thiet lap Rows len muc cao high
		*pOutPutDataReg |= 0x0F;
		//6.2 Thiet lap R2 LOW(PD1)
		*pOutPutDataReg &= ~(1 << 1);

		//7.2 Quet cac cot
		//Check C1(PD8) low or high
		if(!(*pInPutDataReg & (1 << 8)))
		{
			//key dc nhan
			delay();
			printf("4\n");
		}

		//Check C2(PD9) low or high
		if(!(*pInPutDataReg & (1 << 9)))
		{
			//key dc nhan
			delay();
			printf("5\n");
		}

		//Check C3(PD10) low or high
		if(!(*pInPutDataReg & (1 << 10)))
		{
			//key dc nhan
			delay();
			printf("6\n");
		}

		//Check C4(PD11) low or high
		if(!(*pInPutDataReg & (1 << 11)))
		{
			//key dc nhan
			delay();
			printf("B\n");
		}



		//5.3 Thiet lap Rows len muc cao high
		*pOutPutDataReg |= 0x0F;
		//6.3 Thiet lap R3 LOW(PD2)
		*pOutPutDataReg &= ~(1 << 2);

		//7.3 Quet cac cot
		//Check C1(PD8) low or high
		if(!(*pInPutDataReg & (1 << 8)))
		{
			//key dc nhan
			delay();
			printf("7\n");
		}

		//Check C2(PD9) low or high
		if(!(*pInPutDataReg & (1 << 9)))
		{
			//key dc nhan
			delay();
			printf("8\n");
		}

		//Check C3(PD10) low or high
		if(!(*pInPutDataReg & (1 << 10)))
		{
			//key dc nhan
			delay();
			printf("9\n");
		}

		//Check C4(PD11) low or high
		if(!(*pInPutDataReg & (1 << 11)))
		{
			//key dc nhan
			delay();
			printf("C\n");
		}



		//5.4 Thiet lap Rows len muc cao high
		*pOutPutDataReg |= 0x0F;
		//6.4 Thiet lap R4 LOW(PD3)
		*pOutPutDataReg &= ~(1 << 3);

		//7.4 Quet cac cot
		//Check C1(PD8) low or high
		if(!(*pInPutDataReg & (1 << 8)))
		{
			//key dc nhan
			delay();
			printf("*\n");
		}

		//Check C2(PD9) low or high
		if(!(*pInPutDataReg & (1 << 9)))
		{
			//key dc nhan
			delay();
			printf("0\n");
		}

		//Check C3(PD10) low or high
		if(!(*pInPutDataReg & (1 << 10)))
		{
			//key dc nhan
			delay();
			printf("#\n");
		}

		//Check C4(PD11) low or high
		if(!(*pInPutDataReg & (1 << 11)))
		{
			//key dc nhan
			delay();
			printf("D\n");
		}
	}

}
