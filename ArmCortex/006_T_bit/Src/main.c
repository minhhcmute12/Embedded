/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/**
 * Discussion about T bit of the EPSR - Thảo luận về bit T của EPSR
 * ------------------------------------------------------------------
 * *Giới thiệu T bit (kết hợp với bài 003_2CoreRegister)
 * Trong lập trình nhúng, thuật ngữ "T bit" thường được sử dụng để chỉ một bit trong thanh ghi trạng thái hoặc thanh ghi
 * kiểm soát của một thiết bị ngoại vi hoặc một vi điều khiển.
 * T bit có thể đại diện cho một loạt các tình trạng, điều kiện hoặc cờ trong một thiết bị ngoại vi như trạng thái hoạt động,
 * trạng thái lỗi, hoặc trạng thái sẵn sàng. Nó có thể được sử dụng để kiểm tra hoặc kiểm soát các điều kiện hoặc sự kiện
 * xảy ra trong hệ thống nhúng.
 * Ví dụ, trong một vi điều khiển, có thể có một thanh ghi trạng thái với T bit để chỉ trạng thái hoạt động của vi điều khiển.
 * Khi T bit là 1, nghĩa là vi điều khiển đang hoạt động; khi T bit là 0, nghĩa là vi điều khiển không hoạt động.
 * Cách sử dụng và ý nghĩa của T bit có thể khác nhau tùy thuộc vào thiết bị cụ thể và ngữ cảnh ứng dụng trong lập trình nhúng.
 * Thông thường, tài liệu hướng dẫn và tài liệu kỹ thuật của thiết bị sẽ cung cấp thông tin chi tiết về ý nghĩa và tác dụng
 * của T bit trong ngữ cảnh cụ thể đó.
 *
 * *Một số lưu ý:
 * 1) Nhiều bộ xử lý ARM khác nhau hỗ trợ liên kết giữa ARM-Thumb, nghĩa là khả năng chuyển đổi giữa trạng thái ARM và Thumb.
 *
 * 2) Bộ xử lý phải ở trạng thái ARM để thực hiện các lệnh từ ARM ISA và bộ xử lý phải ở trạng thái Thumb để thực hiện các
 * lệnh của ISA Thumb.
 *
 * 3) Nếu bit 'T' của EPSR được đặt (1), bộ xử lý nghĩ rằng lệnh tiếp theo mà nó sắp thực hiện là từ Thumb ISA.
 *
 * 4) Nếu bit 'T' của EPSR được đặt lại (0), bộ xử lý cho rằng lệnh tiếp theo sắp thực thi là từ ARM ISA.
 *
 * 5) Bộ xử lý cortex Mx không hỗ trợ trạng thái "ARM ISA". Do đó, giá trị của bit 'T' phải luôn là 1.
 * Không duy trì điều này là bất hợp pháp và điều này sẽ dẫn đến ngoại lệ "Lỗi sử dụng" xảy ra.
 *
 * 6) Lsb(bit 0) của bộ đếm chương trình (PC) được liên kết với bit 'T' này.
 * Khi bạn tải một giá trị hoặc một địa chỉ vào PC, Bit[0] của giá trị đó được tải vào T-bit.
 *
 * 7) Do đó, bất kỳ địa chỉ nào bạn đặt trong PC phải có bit thứ 0 là 1.
 * Điều này thường được thực hiện bởi trình biên dịch và các lập trình viên không cần phải lo lắng trong hầu hết thời gian.
 *
 * 8) Đây là lý do tại sao bạn thấy tất cả các địa chỉ vectơ được tăng thêm 1 trong bảng vectơ.
 *
 */

#include<stdio.h>
#include<stdint.h>

/* This function executes in THREAD MODE of the processor */
void generate_interrupt()
{
	uint32_t *pSTIR  = (uint32_t*)0xE000EF00;
	uint32_t *pISER0 = (uint32_t*)0xE000E100;

	//enable IRQ3 interrupt
	*pISER0 |= ( 1 << 3);

	//generate an interrupt from software for IRQ3
	*pSTIR = (3 & 0x1FF);

}

void change_access_level_unpriv(void)
{

	//read
	__asm volatile ("MRS R0,CONTROL");
	//modify
	__asm volatile ("ORR R0,R0,#0x01");
	//write
	__asm volatile ("MSR CONTROL,R0");

}

/* This function executes in THREAD MODE+ PRIV ACCESS LEVEL of the processor */
int main(void)
{
	printf("In thread mode : before interrupt\n");

	void (*fun_ptr)(void);  //Step_1: Tạo 1 con trỏ hàm

   /* Step_2 : storing some address in the function pointer variable - lưu trữ một số địa chỉ trong biến con trỏ hàm */
	//Vd1: gán địa chỉ của hàm change_access_level_unpriv cho con trỏ mới tạo
	//fun_ptr = change_access_level_unpriv;

	//Vd2: gán con trỏ hàm với 1 địa chỉ có bit0=0 và ko đc R15 hỗ trợ
	fun_ptr = (void*)0x080001e8;

	fun_ptr();   //Step_3: gọi con trỏ hàm đó

	//Vd1: khi gọi con trỏ hàm sẽ thực hiện hàm change_access_level_unpriv()
	//Khi vào bảng Variable để quan sát cách hoạt động biến fun_ptr thì ta sẽ thấy ở Binary, bit 0 có value là 1
	//Giải thích: khi chạy lệnh gọi hàm con trỏ thì sẽ chạy hàm change_access_level_unpriv(gọi value của con trỏ là địa chỉ hàm).
	//Tuy nhiên, vì hàm change_access_level_unpriv sẽ tác động vào các thanh ghi đặc biệt nên trình biên dịch sẽ phải
	//kiểm tra địa chỉ của hàm đó (nói cách khác là kiểm tra value địa chỉ đó có bit cuối là 0 hay 1).
	//Phải kiểm tra vì trước đc phép tác động vào thanh ghi, chương trình sẽ chuyển bit cuối của địa chỉ hàm vào trong T-bit
	//mà đối với vi xử lý Cortex Mx thì nếu T-bit=0 thì sẽ báo lỗi ngoại lệ và chỉ hoạt động ở T-bit=1.

	//Khi trình biên dịch kiểm tra nếu bit0=1 sẵn thì sẽ tiến hành bước chuyển value vào T-bit. Tuy nhiên khi bit0=0, thì
	//trước khi chuyển vào T-bit,trình biên dịch sẽ thực hiện lệnh cộng bit lên 1 thông qua Program Counter(R15).
	//Sau khi cộng sẽ đc chuyển vào T-bit, nhắc, địa chỉ đc cộng 1 của hàm sẽ đc đưa vào PC chứ ko phải địa chỉ cũ nữa.
	//Lưu ý: ko cần quá lo lắng điều này vì có thành ghi Program Counter, lập trình viên cứ lập trình bình thường.
	//Vì đây chỉ là quá trình hoạt động bên trong PC.

	//Vd2:
	 /* Here the address 0x080001e8 gets copied into PC  - Tại đây, địa chỉ 0x080001e8 được sao chép vào PC
	   * 0th bit of the address will be copied into T bit. - Bit thứ 0 của địa chỉ sẽ được sao chép vào bit T.
	   *Since the 0th bit is 0, T bit becomes 0 which raises processor fault - Vì bit thứ 0 là 0, bit T trở thành 0 làm
	   * gây lỗi bộ xử lý*/

	//==> Khi bạn thực hiện các hành động tác động vào địa chỉ thanh ghi của Core Register Mx thì bắt buộc phải để ý
	//đến T-bit(phải =1). KHÔNG nên gán trươc tiếp địa chỉ mà hãy gán bằng lệnh Assembly hoặc C bình thường, việc xử lý
	//T-bit = 1 thì hãy để cho trình biên dịch và R15 giải quyết.

	printf("In thread mode : after interrupt\n");

	for(;;);
}

/* This function(ISR) executes in HANDLER MODE of the processor */
void RTC_WKUP_IRQHandler(void)
{
	printf("In handler mode : ISR\n");
}

void HardFault_Handler(void)
{
	printf("Hard fault detected\n");
	while(1);
}



/**
 * Discussion about T bit of the EPSR
-------------------------------------------------------
1) Various ARM processor support ARM-Thumb interworking, that means the ability to switch between ARM and Thumb state.
2) The processor must be in ARM state to execute instructions which are from ARM ISA and the processor must be in Thumb state to execute instructions of the Thumb ISA.
3)  If 'T' bit of the EPSR is set (1), processor thinks that the next instruction hich it is about to execute is from Thumb ISA.
4) If 'T' bit of the EPSR is reset (0), processor thinks that the next instruction which is about to execute is from ARM ISA.
5) The cortex Mx processor does not support the "ARM" state. Hence, the value of 'T' bit must always be 1.
Failing to maintain this is illegal and this will result in the "Usage fault" exception.
6)  The lsb(bit 0) of the program counter(PC) is linked to this 'T' bit.
When you load a value or an address in to PC the Bit[0] of the value is loaded into the T-bit.
7) Hence, any address you place in the PC must have its 0th bit as 1.
This is usually taken care by the compiler and programmers need not to worry most of the time.
8) This is the reason why you see all vector address are increment by 1 in the vector table.
 */
