/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

/**
 * S6: ARM GCC inline_assembly_code(IAC) usage - Sử dụng inline(nội tuyến) code assembly trong ARM GCC
 * ------------------------------------------------------------------------------------------
 *
 * Chúng ta sử dụng IAC để truy cập vào các thanh ghi lõi(core register) của bộ vi xử lý như là các thanh ghi mục đích chung,
 * thanh ghi dạng đặc biệt, hay stack pointer. Nguyên nhân vì đây đều là các thanh ghi dạng Non-memory mapped register, chúng ko
 * đc phép truy cập bằng code C thông thường mà phải thông qua IAC.
 * Core Register: là thanh ghi nằm trong lõi của con vi xử lý(nhân ARM)chứ không phải là các thanh ghi ngoại vi vi điều khiển.
 *
 * Để sử dụng IAC thì bạn phải biết đc cú pháp hoạt động quan trọng của chúng vì các trình biên dịch khác nhau sẽ có cú pháp
 * khác nhau. Ví dụ với GCC có 1 loại cú pháp, IAR compiler có 1 loại cú pháp, và ARM compiler có một loại khác.
 *
 * Ví dụ: bạn muốn đưa hướng dẫn assembly "MOV R0,R1" vào chương trình C đối với trình biên dịch ARM GCC
 * Cú pháp IAC: _asm volatile("MOV R0,R1");
 * Với: _asm : từ khóa
 * 		volotile : kiểu biến tùy chọn, và thường là volotile luôn để tránh việc tối ưu hóa từ trình biên dịch
 * 		MOV R0,R1 : hướng dẫn asembly muốn đưa vào, nhớ phải đặt trong cặp dấu ngoặc đơn và ngoặc kép, kết thúc bằnng dấu ';'
 *
 * Vd2: Cho các lệnh asembly sau và cho vào chương trình
 * 	. LDR R0,[R1]   	LDR: load
 * 	. LDR R1,[R2]
 * 	. ADD R1,R0			ADD : adding
 * 	. STR R1,[R3]		STRR: store-lưu trữ
 *
 * 	void fun_add(void)
 * 	{
 * 		//Cách 1: viết 4 dòng code
 * 		_asm volatile("LDR R0,[R1]");
 * 		_asm volatile("LDR R1,[R2]");
 * 		_asm volatile("ADD R1,R0");
 * 		_asm volatile("STR R1,[R3]");
 *
 * 		//Cách 2: viết trong 1 dòng code
 * 		_asm volatile("LDR R0,[R1]\n\t"
 * 					  "LDR R1,[R2]\n\t"
 * 					  "ADD R1,R0\n\t"
 * 		       	      "STR R1,[R3]\n\t");
 * 	}
 *
 * 	*'C' variable and inline assembly
 * 	Câu hỏi: Tại sao phải sử dụng IAC trong chương trình C?
 * 	Xét tình huống: bạn muốn chuyển data của biến 'C' vào trong thanh ghi ARM R0 hoặc ngược lại bạn muốn chuyển nội dung của
 * 	thanh ghi CONTROL sang biến C thuần là "control_reg".
 * 	Như đã nói bạn không thể làm điều này bằng cách sử dụng các câu lệnh C thuần túy mà bạn phải sử dụng IAC.
 *
 * 	*Định dạng chung của câu lệnh IAC của trình biên dịch ARM GCC
 * 	Cú pháp: _asm volatile(code : output operand list : input operand list : clobber list)
 * 	Với: _asm : từ khóa lệnh IAC
 * 		 volatile : kiểu biến(thường mặc định), ở đây là yêu cầu trình biên dịch không đc tối ưu hóa lệnh này
 * 		 code : định nghĩa hành động IAC, vd:
 * 		 output operand list : khối toán hạng đầu ra
 * 		 input operand list : khối toán hạng đầu vào
 * 		 Clobber list: chủ yếu được sử dụng để thông báo cho trình biên dịch về việc sửa đổi được thực hiện bởi mã trình biên
 * 		 dịch chương trình.
 * 		 Cách lệnh bên trong đc cách nhau bằng dấu ":" và kết thức bằng dấu ";"
 *
 * Ví dụ: _asm volatile("MOV R0,R1");    <=>  _asm volatile("MOV R0,R1:::");
 * Ở ví dụ này chỉ có khối "code" chứ không có các thành phần khác bên trong dấu ngoặc đơn của câu lệnh chính
 *
 * Lưu ý: Các từ khóa sử dụng trong IAC(phần 3.5: General data processing instructions)
 */

/**
 * Input/Output operands(toán tử) and Constraint string
 * -----------------------------------------------------
 * Mỗi toán hạng đầu vào và đầu ra được mô tả bởi một chuỗi ràng buộc theo sau là một biểu thức C trong ngoặc đơn.
 *
 * Cú pháp:  "<Constraint string>" (<'C' expresion>)
 * Constraint string = constraint character + constraint modifier
 *
 * Example1: Di chuyển nội dung của biến 'val' thuộc 'C' sang thanh ghi R0 của ARM
 * Từ khóa(Instruction) ==> MOV
 * Nguồn(Source) 		==> a 'C' biến 'val' (INPUT)
 * Đích(Destination)	==> R0 (ARM core register)
 *
 * --> _asm volatile("MOV R0,%0": : "r"(val));
 * Giải thích: + MOV R0,%0 -> phần code, '%0' : Lập chỉ mục toán hạng sử dụng dấu % theo sau là một chữ số
						%0 đề cập đến toán hạng đầu tiên, chính là giá trị của biến val.
						%1 đề cập đến toán hạng thứ hai, v.v.(so forth), nếu val có thêm 1 biểu thúc hay toán hạng nữa thì
						sẽ lấy toán hạng đó thay vì lấy giá trị biến val.
 * + không có phần output ở giữa;
 * + "r"(val) :phần input, trong đó 'r' là Constraint string với mục đích là yêu cầu đọc value của biến;
 * + 'val': là biến cần đọc.
 *
 * Lưu ý: Constraint string có rất nhiều dạng nên cần tham khảo tài liệu khi sử dụng các mục đích khác
 *
 * Example2: Di chuyển nội dung của thanh ghi 'CONTROL' của ARM sang biến 'control_reg' thuộc 'C'
 * Lưu ý: thanh ghi 'CONTROL' là một thanh ghi đặc biệt của ARM core nên để đọc đc thanh ghi này ta phải sử dụng từ khóa 'MRS'
 *
 * Từ khóa(Instruction) ==> MRS
 * Nguồn(Source) 		==> CONTROL (ARM core register)
 * Đích(Destination)	==> A 'C' biến 'control_reg' (OUTPUT operand)
 *
 * --> _asm volatile("MRS %0,CONTROL": "=r"(control_reg)::);
 * Giải thích: MRS %0,CONTROL : phần code, với %0 là đích, CONTROL là nguồn
 * + Không có phần input và clobber list;
 * + "=r"(control_reg) : phần output, "=r" là Constraint string với mục đích là yêu cầu gán vào value của biến;
 * + control_reg : là biến cần lưu giá trị đọc đc từ CONTROL.
 *
 * Lưu ý: MRS : yêu cầu di chuyển từ thanh ghi đặc biệt sang thanh ghi nào đó
 * 		  MSR : yêu cầu di chuyển từ thanh ghi nào đó sang thanh ghi đặc biệt
 * 		  Xem thêm ở chương 3(Cortex M4 instruction Set) -> phần 3.12 (Miscellaneous instruction)
 *
 * Example3: Di chuyển nội dung của biến var1 sang biến 'car2' thuộc 'C'
 * Từ khóa(Instruction) ==> MOV
 * Nguồn(Source) 		==> A 'C' biến 'var1' (INPUT operand)
 * Đích(Destination)	==> A 'C' biến 'var2' (OUTPUT operand)
 * --> _asm volatile("MOV %0,%1": "=r"(var2):"r"(var1):);
 * Giải thích: + "MOV %0,%1" : phần code, với đích %0 là đại diện cho biểu thức "=r"(var2),
 * 											  nguồn %1 là đại diện cho biểu thức "r"(var1);
 * + Không có phần clobber list;
 * + =r"(var2): ghi giá trị vào biến, "r"(var1): đọc giá trị biến.
 *
 * Example4: di chuyển nội dung của contrỏ  *p2 sang biến p1 thuộc 'C'
 * int p1,*p2;
 * p2 = (int *0x20000008);
 * _asm volatile("LDR %0,[%1]" : "=r"(p1):"r"(p2): ) ;		//p1 = *p2
 * Giải thích: [%1] : lấy giá trị của con trỏ
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
{
	//vd1: sử dụng IAC
//	__asm volatile("LDR R1,=#0x20001000");	//LDR R1,=#0x20001000 : load địa chỉ 0x20001000(value = 0x6) vào thanh ghi R1
//	__asm volatile("LDR R2,=#0x20001004");	//LDR R1,=#0x20001000 : load địa chỉ 0x20001004(value = 0x4) vào thanh ghi R2
//	__asm volatile("LDR R0,[R1]");	//LDR R0,[R1] : load giá trị của địa chỉ mà thanh ghi R1 đang lưu vào thanh ghi R0(value = 6)
//	__asm volatile("LDR R1,[R2]");	//LDR R1,[R2] : load giá trị của địa chỉ mà thanh ghi R2 đang lưu vào thanh ghi R1(value = 4)
//	__asm volatile("ADD R0,R0,R1");	//ADD R0,R0,R1 : toán hạng tổng hợp giá trị thanh ghi R0 và R1 vào thanh ghi R0 (value = 0xa)
//	__asm volatile("STR R0,[R2]");	//STR R0,[R2] : lưu value(0xa) mà R0 đang lưu về cho value của địa chỉ mà R2 đang lưu

	//vd2: sử dụng Constraint string
#if 0  //ko dùng các dòng code này khi biên dịch
	__asm volatile("LDR R1,=#0x20001000");
	__asm volatile("LDR R2,=#0x20001004");
	__asm volatile("LDR R0,[R1]");
	__asm volatile("LDR R1,[R2]");
	__asm volatile("ADD R0,R0,R1");
	__asm volatile("STR R0,[R2]");
#endif

	//vd2.1: sử dụng phần INPUT
	/* store 'val' in to R0*/
	int val=50;
	__asm volatile("MOV R0,%0": :"r"(val));
	//Xem thêm video(29.ARM GCC IAC part 3) về cách chạy của việc di chuyển giá trị val(từ trong RAM) sang thành ghi R0
	//Cách chạy: sau khi đọc giá trị của val, trình biên dịch không di chuyển giá trị đó vào R0 ngay mà đầu tiên sẽ quy đổi
	//giá trị biến val sang mã HEX(50==0x32) sau đó sẽ lưu 0x32 vào thanh ghi trung gian(thường là R3) sau đó mới từ R3
	//di chuyển vào thanh ghi R0. Việc quy đổi chính là tác dụng của phần '%0'
	//Thêm: sau khi đã build thì bạn có thể vào phần inline_1.list để xem cách chạy của dòng code

	//vd2.2: sử dụng phần OUTPUT
	/*read CONTROL register value in to control_reg variable */
	int control_reg;
	__asm volatile("MRS %0,CONTROL": "=r"(control_reg) );
	//Cách chạy: sau khi đọc giá trị thanh ghi CONTROL, trình biên dịch sẽ đưa value đó vào thanh ghi trung gian(thường là R3)
	//và từ R3 sẽ di chuyển vào địa chỉ của biến control_reg

	//vd2.4: con trỏ
    /* Read the value present at pointer p2 in to p1 */
	int p1, *p2;
	p2 = (int*)0x20000008;
	__asm volatile("LDR %0,[%1]": "=r"(p1): "r"(p2));
	//Cách chạy: đầu tiên trình biên dịch sẽ lưu giá trị địa chỉ mà con trỏ p2 đang lưu vào thanh ghi R3, sau đó,
	//tiếp tục đọc giá trị của địa chỉ đc lưu ở R3 đó lưu đè tiếp tục ở R3(tác dụng của lệnh [%1]) , sau đó mới lấy giá trị
	//ở R3 lưu vào biến p1(đưa vào địa chỉ biến p1)

	for(;;);
}

/**
 * S7: Reset Sequence of the Cortex M Processor
 * ---------------------------------------------
 * Khi bạn reset Vi xử lý(processor), nghĩa là bạn gửi tín hiệu đặt lại đến bộ vi xử lý của bộ vi điều khiển.
 * Lưu ý: trên bảng mạch có nút reset sẽ tương đương chức năng này. Các bước tiếp theo sẽ xảy ra:
 *
 * 1) Khi bạn reset Vi xử lý(processor), Máy tính sẽ load với giá trị tại địa chỉ 0x0000_0000 của bộ nhớ.
 *
 * 2) Khi đó, vi xử lý sẽ đọc và lưu giá trị của bộ nhớ(Memory: ROM hoặc Flash) tại vị trí 0x0000_0000 vào MSP.
 * MSP = value@0x0000_0000
 * MSP : Main_Stack_Pointer Register : thanh ghi con trỏ ngăn xếp, 32bit.
 * -> Bộ vi xử lý sau khi đc reset sẽ tiến hành khởi tạo MSP trước tiên.
 *
 * 3) Vi xử lý sẽ tiếp tục đọc giá trị của bộ nhớ tại vị trí 0x0000_0004 của PC.
 * Giá trị đó chính là địa chỉ của bộ reset handler(bộ xử lý đặt lại)
 *
 * 4) PC sẽ tiến hành thực hiện reset handler.
 *
 * 5) Trình xử lý đặt lại chỉ là một hàm C hoặc hàm Assembly do bạn viết để thực hiện bất kỳ khởi tạo nào được yêu cầu.
 *
 * 6) Từ reset hadnler, bạn sẽ gọi hàm Main() của ứng dụng.
 *
 *
 * ***Giải thích về cấu trúc các file trong một project STM32:
 * ---------------------------------------------------------
 *
 * File Startup: chứa file trình khởi động project. trong file này có chứa các câu lệnh dùng để khởi động, cấu hình thanh ghi.
 * vd: Lệnh Reset Handler(Reset-> Khởi tạo dữ liệu -> Khởi tạo BSS -> Khởi tạo các thư viện 'std' của C -> hàm Main)
 *
 * File Includes: Chứa các file thư viện chuẩn 'std' của C
 *
 * File Inc: Chứa các file thư viện do lập trình viên viết. Mặc định sẽ trống khi tạo project
 *
 * File Src: chứa file main và các file nền cho việc chạy chương trình hàm main(syscall và sysmem)
 */
