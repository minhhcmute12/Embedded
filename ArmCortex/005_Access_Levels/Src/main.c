/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/**
 * S8: Access level(Mức truy cập) and T-bit
 * -------------------------------------------
 *
 * V33: Demonstration of access level of the processor - Trình bày ví dụ về mức độ truy cập của vi xử lý
 */

#include<stdio.h>
#include<stdint.h>

/*
 * This function executes in THREAD MODE of the processor
 * Chức năng này thực hiện trong CHẾ ĐỘ THREAD của bộ xử lý
 */
void generate_interrupt()
{
	uint32_t *pSTIR  = (uint32_t*)0xE000EF00;
	uint32_t *pISER0 = (uint32_t*)0xE000E100;

	//enable IRQ3 interrupt
	*pISER0 |= ( 1 << 3);

	//generate an interrupt from software for IRQ3
	*pSTIR = (3 & 0x1FF);

	//Nếu bạn đang ở mức NPAL mà vẫn cố gắng truy cập thanh ghi đặc biệt IRQ3 thì chương trình báo lỗi
	//và nhảy xuống thực hiện hàm HardFault_Handler
	//Vì vậy cần chuyển chương trình về mức PAL để có thể truy cập thanh ghi đặc biệt
}

/**
 * Chương trình thanh ghi đặc biệt CONTROL
 * Sử dụng Assembly code
 */
void change_access_level_unpriv(void)
{

	//read  //MRS: từ khóa dùng cho các thanh ghi đặc biệt
	__asm volatile ("MRS R0,CONTROL");     //đọc value từ CONTROL sang R0

	//modify //ORR: toán tử OR đối với thanh ghi
	__asm volatile ("ORR R0,R0,#0x01");   //sửa đổi value thanh ghi R0 bằng một phép OR với 0x01
	//Vì thanh ghi CONTROL là thanh ghi định cấu hình access_level là PAL hoặc NPAL

	//write
	__asm volatile ("MSR CONTROL,R0");		//đọc value từ R0 sang CONTROL

	/**
	 * Mục đích của việc hàm change_access_level_unpriv viết trước hàm generate_interrupt:
	 * Vì ở hàm generate_interrupt ta sẽ cần truy cập vào một số thanh ghi đặc biệt để cấu hình ngắt
	 * nhưng có thể chương trình đang ở trạng thái NPAL(ko cho phép truy cập thanh ghi đặc biệt)
	 * nên hàm change_access_level_unpriv giúp ta định cấu hình cho thanh ghi CONTROL qua đó chuyển
	 * đổi mức truy cập về PAL để có thể truy cập vào các thanh ghi đặc biệt ở hàm generate_interrupt
	 */

	/**
	 * Ở các project, trong chế độ Thread_Mode thì thường ta sẽ chuyển CONTROL=0(PAL) sang CONTROL=1(NPAL) để ngăn chặn
	 * các hành động đối với các thanh ghi đặc biệt. Và nếu đã chuyển sang mức NPAL thì ta sẽ ko thể chuyển về mức PAL
	 * ở dạng Thread_Mode đc nữa vì CONTROL cũng là 1 thanh ghi đặc biệt và nếu ở NPAL ta ko đc quyền truy cập thanh ghi
	 * dạng đặc biệt.
	 *
	 * Để có thể chuyển lại từ NPAL->PAL thì ta dùng một ngoại lệ(exception) hoặc một ngắt(interrupt) để làm điều này.
	 * Có nghĩa là chuyển từ chế độ Thread_Mode -> Handler_Mode. Khi ở chế độ Handler_Mode ta sẽ chạy các thanh ghi ISR,
	 * mà các ISR luôn chạy ở mức truy cập PAL nên tại đây bạn có thể chuyển thanh ghi CONTROL về CONTROL=0(PAL).
	 * Sau khi hoàn thành exception/interrupt thì thoát ra và chuyển chế độ về Thread_Mode.
	 */

}

/* This function executes in THREAD MODE+ PRIV ACCESS LEVEL of the processor */
int main(void)
{
	printf("In thread mode : before interrupt\n");

	change_access_level_unpriv();   //Step_1

	generate_interrupt();			//Step_2

	printf("In thread mode : after interrupt\n");

	for(;;);
}

/* This function(ISR) executes in HANDLER MODE of the processor */
void RTC_WKUP_IRQHandler(void)
{
	printf("In handler mode : ISR\n");
}

/**
 * Hàm báo lỗi khi bạn cố gắng truy cập thanh ghi đặc biệt khi đang ở mức NPAL
 */
void HardFault_Handler(void)
{
	printf("Hard fault detected\n");
	while(1);
}
